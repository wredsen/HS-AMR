SCOUT_MODUS (Parklückensuche)

- Linienverfolgung
- Parklückensuche an -> Parklückenvermessung -> ID Festlegung, Ort, Größe
			Parklückenauswertung -> geeignet ja/nein
		     
-> für [HMI]	     -> Anzeige auf App-Karte
-> für [CTR]	     -> Entwicklung Regelalgorithmus Linienverfolgung



Park_This_Modus (Gezieltes Einparken)

- Übergabe von [HMI] Parklücken-ID
- Linienverfolgung zum Ort
- Berechnung Einparkkurve
- Einparken (Route rückwärtsfahren)
-> für [CTR]	     -> Übergabe von Winkel und Geschwindigkeit
- Korrigieren	     -> Messung Platz nach vorne, nach hinten	-> Mittig fahren
- Park_Modus


Park_Out_MODUS (Ausparken)

- Park_Modus bis Ausparksignal
- Ausparken (Route vorwärtsfahren)
-> für [CTR]	     -> Übergabe von Winkel und Geschwindigkeit
- Führungslinie finden/feststellen
- Moduswechsel DRIVE_Modus

PARK_Modus

- warten bis ausparksignal

PAUSE_MODUS (Anhalten)

- von überall in Ruhezustand setzen


???Pause_2_Modus???
-Pause wenn Signal innerhalb der Zustaende Ein/Ausparken kommt
 


***ALLGEMEIN***
- möglichst schnell!
- es gibt nur einen Pacours -> für den soll alles programmiert werden
- Startposition immer gleich	
- Banden für Position nutzbar

[HMI] benötigt: - Pose
		- Parklückendaten (ID, Abmessungen)
		- Programmstatus (Parklücke gefunden, in Parklücke, ...) -> getMethoden implementieren -> return bekommt [HMI]
		
[HMI] sendet:	- Parklücken-ID
		- ausgewählter Modus ( SCOUT, Park_This, Park_Out, Pause, Rangieren/Korrigieren) (optional: Fernsteuerung (letzter Modus))
		- 		



Ich benötige folgende Funktionen:

getter  -> Roboter befindet sich in Slot j/n (Navigation?) getStatus in INAvigation überführen in NavigationAT-klasse
	-> Roboter hat die schwarze Linie wiedergefunden nach Ausparken (Navigation) 


IHMI	-> MODE PARK_OUT 


ICONTROL-> ControlMode PARK_OUT_CTRL

Wenn eine Parklücke gefunden wurde -> ID, Größe, Ort, Lücke groß genug? evt. neue Klasse SLOT?