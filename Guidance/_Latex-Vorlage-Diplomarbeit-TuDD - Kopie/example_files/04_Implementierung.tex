\chapter{Implementierung}

\section{Missionsplaner}
Ausgangspunkt für die Implementierung ist das gegebene Beispielprogramm. In diesem wurde die Hauptzustandsmaschine mit drei Grundzuständen (DRIVE, INACTIVE und EXIT) vorgegeben. Mit Hilfe von Switch-Case-Abfragen wird nur der Code des entsprechenden Zustandes ausgeführt. Nach der Abfrage wird überprüft, ob in einem neuen Zustand gewechselt werden muss.\\


\noindent Die Grundversion verfügt noch über keine Unterzustandsmaschinen. Es fehlen auch die wesentlichen Zustände für das Ein- und Ausparken. Der getätigte Entwurf des Missionsplaners wurde mit weiteren Switch-Case-Abfragen implementiert. \\

\noindent Es stellte sich heraus, dass kleine Änderungen am Entwurf noch korrigiert werden musste. Durch die Überarbeitung des Modells wurde der Roboter effizienter gestaltet, sodass vor allem das Ein- und Ausparken beschleunigt werden konnte. Zum Beispiel musste man keine Routine schreiben, welche die Linie wiederfindet, da das Abfahren der Trajektorie sehr genau funktioniert.

\section{Pfadgenerator}

Zusammen mit dem Controlmodul wurde entschieden, dass im Guidancemodul die Start- und Zielpose, die Geschwindigkeit übergeben wird und zum Schluss der richtige Controlmodus aktiviert wird. Alle Berechnungen werden im Controlmodul getätigt.\\


\noindent Damit das Polynom richtig berechnet wird und anschließend dieses abgefahren werden kann, muss zwischen dem lokalem und globalem Koordinatensystem transformiert werden. Wenn das Fahrzeug im Parkbereich eins einparken muss, wie in Abbildung \ref{img:grafik-Parkluecke} zusehen ist, muss nichts geändert werden. 
Im Parkbereich zwei müssen die x- und y-Achse vertauscht werden. Zusätzlich ist zu beachten, dass die y-Achse gespiegelt werden muss. Im Parkbereich drei müssen beide Achsen gespiegelt werden. \\
\noindent Das Tauschen kann mit Hilfe einer Zwischenspeichervariable einfach realisiert werden. Falls eine Achse gespiegelt werden muss, wird sie mit einer -1 multipliziert.